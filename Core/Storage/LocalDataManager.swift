//
//  LocalDataManager.swift
//  nutrition-app
//
//  Created by Florian Fourcade on 18/02/2025.
//

import Foundation

enum LocalDataError: Error {
    case saveError(String)
    case loadError(String)
    case dataNotFound
    case decodingError(String)
}

class LocalDataManager: ObservableObject {
    static let shared = LocalDataManager()
    
    @Published var userProfile: UserProfile?
    @Published var meals: [Meal] = []
    @Published var weightEntries: [WeightEntry] = []
    @Published var recentScans: [FoodScan] = []
    private var lastSaveTime: Date?
    private let saveDebounceInterval = 0.5
    private var saveLock = NSLock()
    
    private let queue = DispatchQueue(label: "com.yourapp.localdatamanager", qos: .userInitiated)
    
    private init() {
        loadInitialData()
    }
    
    private func loadInitialData() {
        Task {
            do {
                if let profile: UserProfile = try await load(forKey: "userProfile") {
                    print("Profile charg√©:", profile)
                    // Explicitement revenir sur le main thread pour mettre √† jour @Published
                    DispatchQueue.main.async {
                        self.userProfile = profile
                    }
                }
            } catch {
                print("Error loading initial data: \(error)")
            }
        }
    }
    
    func save<T: Encodable>(_ object: T, forKey key: String) async throws {
        return try await withCheckedThrowingContinuation { continuation in
            queue.async {
                do {
                    let encoder = JSONEncoder()
                    encoder.dateEncodingStrategy = .iso8601
                    let data = try encoder.encode(object)
                    UserDefaults.standard.set(data, forKey: key)
                    continuation.resume()
                } catch {
                    continuation.resume(throwing: LocalDataError.saveError(error.localizedDescription))
                }
            }
        }
    }
    
    func load<T: Decodable>(forKey key: String) async throws -> T? {
        return try await withCheckedThrowingContinuation { continuation in
            queue.async {
                guard let data = UserDefaults.standard.data(forKey: key) else {
                    continuation.resume(returning: nil)
                    return
                }
                
                do {
                    let decoder = JSONDecoder()
                    decoder.dateDecodingStrategy = .iso8601
                    let object = try decoder.decode(T.self, from: data)
                    continuation.resume(returning: object)
                } catch {
                    continuation.resume(throwing: LocalDataError.decodingError(error.localizedDescription))
                }
            }
        }
    }
}

extension LocalDataManager {
    // Charger les recettes s√©lectionn√©es
    func loadSelectedRecipes() async throws -> [DetailedRecipe] {
        return try await load(forKey: "selected_recipes") ?? []
    }
    
    // Sauvegarder les recettes s√©lectionn√©es
    func saveSelectedRecipes(_ recipes: [DetailedRecipe]) async throws {
        try await save(recipes, forKey: "selected_recipes")
    }
    
    
    // Ajouter une recette aux s√©lections
    func addToSelection(_ recipe: DetailedRecipe) async {
        do {
            var selectedRecipes = try await loadSelectedRecipes()
            
            // V√©rifier si la recette n'est pas d√©j√† dans les s√©lections
            if !selectedRecipes.contains(where: { $0.name == recipe.name }) {
                selectedRecipes.append(recipe)
                try await saveSelectedRecipes(selectedRecipes)
                print("‚úÖ Recette ajout√©e aux s√©lections: \(recipe.name)")
            }
        } catch {
            print("‚ùå Erreur lors de l'ajout aux s√©lections: \(error)")
        }
    }
    
    // Retirer une recette des s√©lections
    func removeFromSelection(_ recipe: DetailedRecipe) async {
        do {
            var selectedRecipes = try await loadSelectedRecipes()
            selectedRecipes.removeAll { $0.name == recipe.name }
            try await saveSelectedRecipes(selectedRecipes)
            print("‚úÖ Recette retir√©e des s√©lections: \(recipe.name)")
        } catch {
            print("‚ùå Erreur lors du retrait des s√©lections: \(error)")
        }
    }
    
    // V√©rifier si une recette est s√©lectionn√©e
    func isRecipeSelected(_ recipe: DetailedRecipe) async -> Bool {
        do {
            let selectedRecipes = try await loadSelectedRecipes()
            return selectedRecipes.contains(where: { $0.name == recipe.name })
        } catch {
            print("‚ùå Erreur lors de la v√©rification des s√©lections: \(error)")
            return false
        }
    }
    
    // Basculer l'√©tat de s√©lection d'une recette
    func toggleRecipeSelection(_ recipe: DetailedRecipe) async {
        if await isRecipeSelected(recipe) {
            await removeFromSelection(recipe)
        } else {
            await addToSelection(recipe)
        }
    }
    
    
    // Dans LocalDataManager.swift
    func saveFoodEntries(_ entries: [FoodEntry]) {
        
        saveLock.lock()
            defer { saveLock.unlock() }
            // Capturer la pile d'appels
            let callStack = Thread.callStackSymbols
            
            print("SAVE CALL STACK:")
            for (index, call) in callStack.prefix(8).enumerated() {
                print("  \(index): \(call)")
            }
        // √âviter les sauvegardes trop rapproch√©es
        let now = Date()
        if let lastSave = lastSaveTime, now.timeIntervalSince(lastSave) < saveDebounceInterval {
            print("‚ö†Ô∏è Sauvegarde ignor√©e - trop rapproch√©e de la pr√©c√©dente (\(now.timeIntervalSince(lastSave)) sec)")
            return
        }
        
        lastSaveTime = now
        
        // Ajouter l'ID du thread pour d√©bogage
        let threadId = Thread.current.description
        print("üíæ [Thread: \(threadId)] saveFoodEntries appel√© avec \(entries.count) entr√©es")
        
        // Reste de votre code de sauvegarde...
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        do {
            let data = try encoder.encode(entries)
            UserDefaults.standard.set(data, forKey: "foodEntries")
            UserDefaults.standard.synchronize()
            print("‚úÖ Entr√©es du journal sauvegard√©es : \(entries)")
        } catch {
            print("‚ùå Erreur lors de la sauvegarde des entr√©es du journal : \(error)")
        }
    }
    
    
    func loadFoodEntries() -> [FoodEntry]? {
        print("func loadFoodEntries() -> [FoodEntry]?")
        guard let data = UserDefaults.standard.data(forKey: "foodEntries") else {
            return nil
        }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        print("let entries = try decoder.decode([FoodEntry].self, from: data)")
        do {
            let entries = try decoder.decode([FoodEntry].self, from: data)
            // Breakpoint et po ici
            print("‚úÖ Entr√©es du journal charg√©es : \(entries)")
            return entries
        } catch {
            print("‚ùå Erreur lors du chargement des entr√©es du journal : \(error)")
            return nil
        }
    }
}

extension LocalDataManager {
    var savedRecipes: [Recipe]? {
        get {
            guard let data = UserDefaults.standard.data(forKey: "savedRecipes") else {
                return nil
            }
            
            do {
                return try JSONDecoder().decode([Recipe].self, from: data)
            } catch {
                print("Erreur lors du chargement des recettes : \(error)")
                return nil
            }
        }
        set {
            do {
                let data = try JSONEncoder().encode(newValue)
                UserDefaults.standard.set(data, forKey: "savedRecipes")
            } catch {
                print("Erreur lors de la sauvegarde des recettes : \(error)")
            }
        }
    }
    
    func clearFoodEntries() {
        UserDefaults.standard.removeObject(forKey: "foodEntries")
        UserDefaults.standard.synchronize()
        print("‚úÖ Toutes les entr√©es du journal ont √©t√© effac√©es")
    }
}
